# Protobuf 字段

* 👋 Hi, I’m bliu2-10
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...





### 字段

字段格式：

​    role type name = tag [default value]



role 有三种取值：

- required：该字段必须给值，不能为空。否则message被认为是未初始化的。如果试图建立一个未初始化的message将会抛出RuntimeException异常，解析未初始化的message会抛出IOException异常。

- optional：表示该字段是可选值，可以为空。如果不设置，会设置一个默认值。也可以自定义默认值。如果没有自定义默认值，会用系统默认值。

- repeated：表示该字段可以重复，可等同于动态数组。

注意：required字段是永久性的，如果之后不使用该字段，或者该字段标识改为optional或repeated，那么使用就接口读取新协议时，如果发现没有该字段，会认为该消息不完整，会拒收或者丢弃该消息。



### 字段类型

<img src="/home/liubo/00-liubo/my_note/Protocol_Buffers/picture/字段类型.png" alt="字段类型" style="zoom:80%;" />





N 表示打包的字节并不是固定。而是根据数据的大小或者长度。例如int32，如果数值比较小，在0~127时，使用一个字节打包。

关于枚举的打包方式和uint32相同。

关于 fixed32  和int32的区别。fixed32的打包效率比int32的效率高，但是使用的空间一般比int32多。因此一个属于时间效率高，一个属于空间效率高。根据项目的实际情况，一般选择fixed32，如果遇到对传输数据量要求比较苛刻的环境，可以选择int32.





### 字段编号

消息定义中的每个字段都有一个唯一的编号。这些字段编号用于以二进制格式标识您的字段，一旦您的消息类型被使用，就不应该被更改。

Tag的取值范围最小是1,最大是229229-1,但但 19000~19999 是 protobuf 预留的，用户不能使用。

虽然 编号的定义范围比较大，但不同 编号也会对 protobuf 编码带来一些影响：

- 1 ~ 15：单字节编码
- 16 ~ 2047：双字节编码

使用频率高的变量最好设置为1~15，这样可以减少编码后的数据大小，但由于编号一旦指定不能修改，所以为了以后扩展，也记得为未来保留一些 1~15 的 编号





### 字段规则

- singular: 可以有零个或其中一个字段(但不超过一个)。
- repeated: 该字段可以重复任意次数(包括零次)。重复值的顺序将被保留。



### 添加注释

proto 添加注释,使用 C/C++风格的 // 或者 /* … */ 语法.



保留字段

如果通过完全删除某个字段或对其进行注释来更新消息类型，将来的用户可以在对该类型进行自己的更新时重用该字段编号。如果他们以后加载旧版本的相同.proto文件，这可能会导致严重的问题 ，包括数据损坏、隐私漏洞等。
可以把它的变量名或 字段编号 用 reserved 标注，这样，当这个 Tag 或者变量名字被重新使用的时候，编译器会报错

```protobuf
message Foo {
    // 注意，同一个 reserved 语句不能同时包含变量名和 Tag 
    reserved 2, 15, 9 to 11;
    reserved "foo", "bar";
}
```





### 默认值

当解析 message 时，如果被编码的 message 里没有包含某些变量，那么根据类型不同，他们会有不同的默认值：



- string：默认是空的字符串
- byte：默认是空的bytes
- bool：默认为false
- numeric：默认为0
- enums：定义在第一位的枚举值，也就是0
- messages：根据生成的不同语言有不同的表现



**收到数据后反序列化后，对于标准值类型的数据，比如bool，如果它的值是 false，那么我们无法判断这个值是对方设置的，还是对方压根就没给这个变量设置值。**







---
---
---
---
---
---
---
---
---
---
---
---

