# C++中的使用

* 👋 Hi, I’m liubo
* 👀 I’m interested in harmony
* 🌱 I’m currently learning harmony
* 💞️ I’m looking to collaborate on ...
* 📫 How to reach me ...







协议缓冲区编译器还为.proto文件中消息中定义的每个字段生成一组访问器方法。这些方法采用小写字母蛇形命名法，例如has_foo（）和clear_foo（）。



除了访问器方法外，编译器还为每个包含其字段号的字段生成一个整数常量。常量名称是字母k加转换为大小写的字段名再后加FieldNumber。例如，给定可选字段int32 foo_bar=5；，编译器将生成常量静态常量int kFooBarFieldNumber=5；。



对于返回常量引用的字段访问器，当对消息进行下一次修改访问时，该引用可能会无效。这包括调用任何字段的任何非常量访问器，调用从Message继承的任何非常数方法，或通过其他方式修改消息（例如，将消息用作Swap（）的参数）。相应地，只有在没有对消息进行修改访问的情况下，才能保证返回引用的地址在访问器的不同调用中是相同的。



对于返回指针的字段访问器，当对消息进行下一次修改或非修改访问时，该指针可能无效。这包括，无论常量如何，调用任何字段的任何访问器，调用从Message继承的任何方法，或通过其他方式访问消息（例如，使用复制构造函数复制消息）。相应地，返回指针的值在访问器的两个不同调用中永远不能保证相同。











现在尝试使用协议缓冲区类。希望通讯簿应用程序能够做的第一件事是将个人详细信息写入通讯簿文件。要做到这一点，需要创建并填充协议缓冲区类的实例，然后将它们写入输出流。



这里有一个程序，它从文件中读取地址簿，根据用户输入向其中添加一个新的Person，然后将新的地址簿再次写入文件。突出显示了直接调用或引用协议编译器生成的代码的部分。













.pb.h里生成了一个协议数据结构体与操作该结构体的一些接口，有几个message就生成几个类，包括组包与解包（序列化与反序列化）接口，对应的.pb.cc里就是这些接口对应的实现。








































---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---
---